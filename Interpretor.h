#pragma once
#include "Token.h"
#include "VertexObject.h"
#include "InstructionExpression.h"
#include <vector>
#include <string>
#include <map>
//Class Interpretor interpret program directely after lexing
class Interpretor
{
protected:
	std::map<std::string, VertexObject> vertices;//runtime storage for vertex info
	std::map<std::string, double> input_vars;//runtime storage for input_var info
	std::vector<Token*> streams;//runtime storage for Tokens generated by lexer
	int position=0;//current token index position
	Token* ct=NULL;//current token
	void next();//move forward on tokens
	void previous();//move backward on tokens
	Token* eat(TT type);//eat token with type if type not matched then error comes expected this get another
	std::string getByType(TT type);//return string value of type
	void executeSequence(std::vector<std::string> sequence);
	VertexObject operate(VertexObject out, double in);
	InstructionExpression* buildExpression(std::vector<std::string> seq,std::string s, int i);
	InstructionExpression* evaluate(InstructionExpression* exp);
public:
	Interpretor(std::vector<Token*> stream);
	void interpret();
};

